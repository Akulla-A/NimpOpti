================================================
 Register allocation for local variables in IMP
================================================

We take as starting point a simple MIPS compiler for the core imperative
language IMP, where:

- expressions are computed using registers $t0 to $t9
- local variables are allocated on the stack

The goal of this exercise is to allocate (part of) the local variables in
registers $s0 to $s7. The allocation is performed separately for each function.

We propose the following strategy for allocating local variables of a function:
1/ number the instructions in textual order
2/ compute the set of variables that are live on entry to each numbered instruction
3/ deduce a liveness interval for each local variable
4/ perform a linear scan of the liveness intervals and associate each variable
   to a register or a stack location

4/ Linear scan.
---------------
The linear scan register allocation algorithm scans all liveness intervals
in chronological order. For this, the liveness intervals of variables are
sorted by ascending lower bound, with equals sorted by ascending upper bound.
We consider as "current time" the starting date (ie: lower bound) of the next
interval.

The algorithm uses three data structures:
* A list [active] of currently active live intervals, sorted by ascending
  upper bound. The active intervals have two properties: they contain the
  current time, and they correspond to a variable allocated to a register.
  The list is initially empty.
* A list [available] of currently available registers. Initially, it contains
  all the registers [$s0-$s7].
* A hashtable [alloc] giving an allocation for every variable already scanned.
  An allocation can be either one of the registers, or a special value 
  indicating that the variable will be stored on the stack (a variable stored
  on the stack is called a "spill" variable)

The algorithm then considers each liveness interval (x,[a:b]) in order and
perform the following steps. Let [x] be the variable associated to the
considered interval.
* For each active interval (x',[a':b']) whose upper bound is smaller than [b],
  remove (x',[a':b']) from active, and put back the register associated to [x']
  into the [available] list.
* If the [available] list is not empty, remove one of its registers and
  associate it to [x]. Then put the interval in [active]. Reminder: the [active]
  list should be sorted by ascending upper bound.
* Otherwise, allocate [x] on the stack.

Improvement: if the [available] list is empty, and at least one active interval
(x',[a':b']) has an ending date b' > b, then
- associate [x] to the register that was initially given to [x']
- allocate [x'] on the stack instead
- remove (x',[a':b']) from the [active] list, and insert (x,[a:b]) instead (at
  the appropriate position)
  
  
Tasks
=====

This folder contains a standalone and working Imp to Mips compiler.

The following files are new, or of particular interest.
  - nimp.ml        AST with numbered instructions
  - imp2mips.ml    basic translation to mips
  - liveness.ml    skeleton for liveness analysis
  - linearscan.ml  skeleton for linear scan allocation

There are also the already known following files.
  - imp.ml         AST
  - implexer.mll   parsing (lexical part)
  - impparser.mly  parsing (grammatical part)
  - impc.ml        main
  - mips.ml        mips assembly


Main task
---------
You have to complete the two files [liveness.ml] and [linearscan.ml], and
adapt the file [imp2mips.ml] to build an optimizing Imp to Mips compiler.
Look for [failwith "not implemented"] of [TODO] to identify places where
something must be added or modified.

Altenatively, you can mix these additional elements with your current project.

Advice:
- Test your compiler with new IMP files tailored to trigger interesting
  behaviours of the allocator.
- The code is parametric in the set of registers used for various purposes
  (see the beginning of [imp2mips.ml]). Do not hesitate to modify these sets
  to make the tests more interesting. In particular, try with a limited
  number of available registers.
- Writing small functions for printing data on the allocation is useful for
  debugging the allocator. For instance: printing the live sets, the live
  intervals, or the steps of the allocator.

Extensions
----------
You may implement any of these suggested extensions, or add your own.

C. The current version of [imp2mips] passes all function arguments on the stack.
   Extension: use registers [$a0] to [$a3] for the first four parameters, and
   the stack only starting from the fifth parameter.
   Remark: at the very least, these registers have to be saved/restored at the
   appropriate point of each function call. Their contents can also be
   considered as a local variable that is managed by the allocator.

D. Liveness analysis allows to identify "dead" [set] instructions, that is
   instruction that set a variable with a value which will surely never be
   used.
   Extension: add a pass that remove these dead instructions.
   Remark: you should not remove a set to a dead variable if the instruction
   itself contains another possibly visible side-effect.

E. The current version of [imp2mips] manages separately the registers for the
   intermediate values of the computation of an expression and for the local
   variables.
   Extension: add a pass that flatten all expressions and explicitely uses
   local variables for intermediate values. Then use only one allocation for
   all these variables.

Z. Replace linear scan allocation with graph coloring allocation.
